---
layout: post
title:  "fork,execve,exit"
date:   2020-10-29 11:29:00
categories: Linux
tags: OS 操作系统 Linux
excerpt: linux中fork,execve,exit三大系统调用。
mathjax: true
---

# 进程抽象 

OS做的一件事情实际上就是虚拟化，虚拟化的就是为每一个程序提供一个虚拟的执行环境。程序仿佛自己独占CPU执行，但它独占的只是cpu的一部分。在应用程序看来，OS就是提供的一组API。

## 1.fork

在系统启用后只有一个进程，系统必须要提供一个系统调用来创建更多进程，这个系统调用就是**fork**。

fork所做的事情就是从当前状态机，做的是当前状态机的一份完整拷贝，代码堆栈等完全拷贝，仅有返回时在主进程返回子进程的进程号，而在子进程返回0。从此以后两个状态机（进程）独立执行，互不相干。如果需要交互就需要进行进程间通信IPC。

### Fork Bomb 💣

有一条有意思的指令是：

```bash
:() { : | : & };:
```

这个bash脚本创建并调用了一个函数，函数名是`:`，内容是创建两个自己并通过管道传递。这个脚本执行后就会不断2分裂创建进程，系统中的进程以指数倍增长，耗尽CPU，最后耗尽内存。



fork的本质是**复制状态机**，因此，fork可能有一些奇怪的现象，但要注意的是：“计算机系统中没有魔法，一切行为都有解释，机器永远是对的。”例如，执行以下代码：

```c
#include <stdio.h>
#include <unistd.h>

int main(void)
{
	for (int i = 0; i < 2; i++)
	{
		fork();
		printf("hello\n");
	}
	return 0;
}
```

如果直接执行，那么终端上打印出的就是6个hello，但如果将他输出到管道，或者重定向到文件，你会发现它打印出了8个。而这根本原因在于向管道或者文件写入时，printf不会直接输出，而是写入一个缓冲区。在第一次fork之后，两个进程各创建出一个缓冲区，然后写入一个hello。第二次fork之后，缓冲区同样被复制，此时就有了4个缓冲区，然后再向缓存区里各写入一个hello。这样，我们就得到了8个hello。

（内容及例子来自于南大OS课程，感谢jyy老师的课程指导。）

## 2.execve

execve系统调用传入3个参数：待执行文件的文件名(路径)，将输入待执行文件的参数，环境变量。

execve会根据传入的文件名和参数，将这个进程转向执行一个新的程序。由于fork和execve的这种特点，linux里也就产生了进程树的概念。

## 3.exit

exit是销毁当前状态机，并返回一个返回值。

可以用`atexit()`注册一个函数，该函数将在程序退出时被调用。

在main函数中使用`return`返回时，程序退出，可以调用`atexit()`。而调用`exit()`时也是一样，exit()是stdlib.h中声明的libc函数，这两者的区别在于return只在主函数中表示整个程序退出，这点不再赘述。

而`_exit()`是glibc中的syscall wrapper（系统调用包装），它会直接终止所有线程，不会调用atexit()。它对应的系统调用是**exit_group**。

最后，直接使用syscall(SYS_exit, 0)是执行exit系统调用终止当前线程，也不会调用atexit()。

## 4.为什么要先fork再exec

除了历史原因之外，重要的一点是，进程持有操作系统的对象，在使用fork时，也会复制这些内容。例如：管道机制，在fork之后，新进程也对应持有管道的写口和读口，这样，父子进程就可以轻易的使用管道进行通讯。

这样的机制优雅的实现了linux世界里**万物皆文件**的机制。这些机制很大程度上促进了unix系统的流行和当今OS的构建。

此外，从性能方面，linux对fork进行优化，采用写时拷贝技术（Copy-on-Write），在fork创建进程时并不直接复制所有内存空间，而是先共享。只有当向内存写入的时候，才拷贝内存空间。这样，在创建子进程和执行execve的时候就很快，不会浪费时间和空间。

fork还有一个神奇的作用是可以给进程打**快照**。