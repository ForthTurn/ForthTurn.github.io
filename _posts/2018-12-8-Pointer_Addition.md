---
layout: post
title:  "指针加法运算的分析"
date:   2018-12-8 22:00:00
categories: 指针
tags: 指针 指针运算
excerpt: 分析指针运算究竟移动多少字节的内存？
mathjax: true
---

刚看到指针的运算时，就有一个疑惑，既然指针实际上是一个4byte的整数，存储了指向对象的内存地址，那么，对指针进行加减法运算时，加的到底是什么？是内存地址吗？加的是位，还是字节？

首先，提到指针的加减法运算，就要提到引出这一内容的部分：数组的指针操作。我们声明一个与数组类型相同的指针，将指针指向数组的某一元素，那么当我们对这个指针加减运算时，毫无疑问，我们就是将指针在数组上前后移动了n个元素。这里，我们可以看出来，因为数组中的元素并不总是只占一个字节，那么如果我们对指针的操作是位或者字节，那么必然会移动到元素中间的位置而产生错误。

再看回C语言的指针在声明的时候，我们需要明确定义指针指向的数据类型，例如，如果我们要分别用几个指针指向`int`型对象、`double`型对象、`char`型对象，我们需要这样定义：

```c
int *point_int;
double *point_double;
char *point_char;
```

按理来说，指针只是存放了一个内存地址而已，对于32位机而言，始终是占用4个byte(=4*8=32bit)，那为什么会需要指定指针指向的对象的类型呢？至少有一个原因是：在我们执行指针加减法操作时，在内存地址上增加的字节数，实际上就是指针所指对象所占用的字节数（sizeof(*pointer)）。

经过测试发现，我们对上面的`point_int`，`point_double`,`point_char`三个指针分别加一时，打印他们前后所储存的内存地址，我们发现，int型增加了4，double型增加了8，char型增加了1。这与他们各自的sizeof是完全一致的，所以，对指针的加减运算，实际加减的字节数跟指针所指向的对象的类型有关。